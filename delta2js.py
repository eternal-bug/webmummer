#!/usr/bin/env python
"""
delta2js.py

Converts mummer .delta files to javascript database for webmummer.
https://github.com/sauloal/webmummer

Saulo Aflitos
Plant Research International - PRI
Cluster Bioinformatics
Wageningen University and Research Centre - WUR
Centre for BioSystems Genomics - CBSG

To Run:
    cd data
    rm <delta folder>/*.js
    delta2js.py <delta folder>/*.delta
    cp <delta folder>/*.js .

Documentation generated by:
    pydoc -w delta2js

License: GPL 2.0
"""

__author__  = "Saulo Aflitos"
__date__    = "Nov 2013"
__version__ = "201311181249"
__credits__ = "mummer, WUR, PRI, CBSG"

import sys, os
import subprocess
import re
from pprint import pprint as pp

#cd data
#rm ../../../out/*.js
#../delta2js.py ../../../out/*.delta
#cp -l ../../../out/*.js .
#rm ../webmummer.tar.xz; tar --exclude .git -ahcvf ../webmummer.tar.xz .


compulsory = ['.delta', '.delta.coords']
"""
compulsory extension of files
"""

forbidden  = ['.invertions.delta.q.delta', '.invertions.delta.q.delta.coords', '.fasta.delta', '.fasta.delta.coords']
"""
forbidden extension of files
"""

labelFields = {
    'refName'    : ['(\S+?)_SL2.40ch\d+'                       , os.path.basename],
    'chromNumber': ['SL2.40ch(\d+)'                            , None],
    'spp'        : ['_\._(\S+)_scaffold_final\.assembly\.fasta', None],
    'status'     : ['\.fasta(\S+)'                             , None]
}
"""
Regular expression to extract information from filenames
"""


titleFmt  = '%(refName)s vs %(spp)s - Chromosome %(chromNumber)s - %(status)s'
xlabelFmt = '%(refName)s Chromosome %(chromNumber)s'
ylabelFmt = '%(spp)s'
"""
output format for title, xlabel and ylabel using the information extracted from file name
"""


for k in labelFields:
    labelFields[k][0] = re.compile( labelFields[k][0] )
"""
pre-compiles RE, replacing the original string
"""

statusMatch  = {
    '.delta'                                       : 'Raw Dot Plot',
    '.delta.coords'                                : 'Raw Dot Plot',
    '.delta.q.delta'                               : 'Clean Dot Plot',
    '.delta.q.delta.coords'                        : 'Clean Dot Plot',
    '.delta.q.delta.filter'                        : 'Clean & Filtered Dot Plot',
    '.delta.q.delta.filter.coords'                 : 'Clean & Filtered Dot Plot',
    '.delta.q.delta.filter.invertions.delta'       : 'Clean & Filtered Dot Plot. Only Inversions',
    '.delta.q.delta.filter.invertions.delta.coords': 'Clean & Filtered Dot Plot. Only Inversions',
}
"""
mapping from extension to stage of processing of file
"""


def statusMatcher( status ):
    """
    Given the extension of the file, return a verbose string describing it to be used in title.
    """
    try:
        return statusMatch[ status ]
    except:
        print "status %s does not have a name" % status
        sys.exit(1)

labelFields['status'][1]= statusMatcher
"""
Adds statusMatcher as a function to be called uppon parsing of file name.
"""

#pointFmt = "[{x:%d,y:%d},{x:%d,y:%d},{n:%d,s:%d,q:%.2f}]," # db format 1.0
#pointFmt = "[%d,%d,%d,%d,%d,%d,%.2f],"                     # db format 2.0
pointFmt = "%d,%d,%d,%d,%d,%d,%.2f,"                        # db format 3.0
"""
All numbers (x1, x2, y1, y2, ref name, qry name, quality) are printed in a single array.
By knowing the array size (7), each register can be recovered by simple arithmetics (k * 7).
"""

#solanum_lycopersicum_heinz_SL2.40ch12.fa_._solanum_pennellii_scaffold_final.assembly.fasta.delta.q.delta.fplot
#solanum_lycopersicum_heinz_SL2.40ch12.fa_._solanum_pennellii_scaffold_final.assembly.fasta.delta.q.delta.rplot

#-- reverse hits sorted by %sim
#0 0 0
#0 0 0


#18542978 36303894 83.8077999012671
#18549032 36297865 83.8077999012671


class exp(object):
    """
    Exporter Class: exports database headers (title, axis labels and limits) and, uppon
    receiving each coordinates, append it to the array.
    """
    def __init__(self, outfile, refName, chromNumber, spp, status, title="title", xlabel="xlabel", ylabel="ylabel"):
        """
        Accepts output file, title and axis labels.
        Initialize limits.
        """
        self.title   = title
        self.xlabel  = xlabel
        self.ylabel  = ylabel
        self.outf    = outfile

        self.minX    = sys.maxint
        self.maxX    = 0

        self.minY    = sys.maxint
        self.maxY    = 0

        self.scaffs  = {}

        self.fhd     = open(outfile, 'w')

        self.dbreg   = "filelist[ '%s' ][ '%s' ][ '%s' ][ '%s' ]" % ( refName, chromNumber, spp, status )

        #outfiles[ refName ][ chromNumber ][ spp ][ status ]
        self.fhd.write("""\

%(dbreg)s[ 'title'  ] = '%(title)s';
%(dbreg)s[ 'xlabel' ] = '%(xlabel)s';
%(dbreg)s[ 'ylabel' ] = '%(ylabel)s';

%(dbreg)s[ 'points' ] = [
""" % { 'dbreg': self.dbreg, 'title': self.title, 'xlabel': self.xlabel, 'ylabel': self.ylabel } )

    def append(self, x1, y1, x2, y2, name, sense, q):
        """
        Adds query name to database of names (a list of all names).
        Exports only species ID (index of the scaffold name in the database of names);

        Replaces sense for 0/1;

        Updates min and max positions;
        """
        if name not in self.scaffs:
            self.scaffs[name] = len(self.scaffs)

        name  = self.scaffs[name]

        sense = 0 if sense == 'fwd' else 1

        line  = pointFmt % ( x1, y1, x2, y2, name, sense, q )

        self.fhd.write( line )

        if x1 > self.maxX: self.maxX = x1
        if x2 > self.maxX: self.maxX = x2

        if x1 < self.minX: self.minX = x1
        if x2 < self.minX: self.minX = x2

        if y1 > self.maxY: self.maxY = y1
        if y2 > self.maxY: self.maxY = y2

        if y1 < self.minY: self.minY = y1
        if y2 < self.minY: self.minY = y2

    def add(self, sense, reg):
        """
        Filters from register only the necessary information.
        Calls self.append;
        """
        #print "adding", reg
        refStart, refEnd, tgtStart, tgtEnd, targetStart, targetEnd, refLen, tgtLen, refSub, tgtSub, idd, refName, tgtName = reg

        self.append( refStart, targetStart, refEnd, targetEnd, tgtName, sense, idd )

    def addOld(self, sense, reg):
        #print "SENSE ", sense, " REG ", reg
        x1   = int(   reg[0][0] )
        y1   = int(   reg[0][1] )
        x2   = int(   reg[1][0] )
        y2   = int(   reg[1][1] )
        q    = float( reg[0][2] )

        self.append( x1, y1, x2, y2, '', sense, q)

    def close(self):
        """
        Exports min/max;
        Exports query species list;
        Closes filehandle;
        """
        line = """\
];

%(dbreg)s[ 'xmin'   ]  = %(minX)12d;
%(dbreg)s[ 'xmax'   ]  = %(maxX)12d;

%(dbreg)s[ 'ymin'   ]  = %(minY)12d;
%(dbreg)s[ 'ymax'   ]  = %(maxY)12d;
%(dbreg)s[ 'scaffs' ]  = [\
""" % { 'dbreg': self.dbreg, 'minX': self.minX, 'maxX': self.maxX, 'minY': self.minY, 'maxY': self.maxY }

        for scaf in sorted(self.scaffs, key=lambda p: self.scaffs[p]):
            #print "spp %s p %d" % (spp, self.spps[spp])
            line += "'%s'," % scaf

        line += '];'

        self.fhd.write( line )

        self.fhd.close()


#var points = [
#    [{x:  0,   y:   1}, {x:   1,   y:   2}, {n: 'first'  , s: 'f'}],
#    [{x:  2,   y:   3}, {x:   3,   y:   5}, {n: 'second' , s: 'f'}],
#    [{x:  4,   y:  13}, {x:   5,   y:   8}, {n: 'third'  , s: 'r'}],
#    [{x:  6,   y:  21}, {x:   7,   y:  34}, {n: 'fourth' , s: 'f'}],
#    [{x:  8,   y:  55}, {x:   9,   y:  89}, {n: 'fifth'  , s: 'f'}],
#    [{x: 10,   y: 144}, {x:  11,   y:1033}, {n: 'sixth'  , s: 'f'}],
#];
#
#var xmin   =    0;
#var xmax   =   30;
#
#var ymin   =    0;
#var ymax   = 1100;
#
#var xlabel = 'xlabel';
#var ylabel = 'ylabel';
#
#var title  = 'title';
#


def parseDelta(delta):
    """
    Converts .delta to .coords (if needed) and parses .coords file.
    """
    coordslines = []
    scafOrder   = []
    scafLens    = {}
    lineCount   = 0

    if not delta.endswith('.coords'):
        show_coords = "show-coords -l -r -T %s" % (delta)
        print show_coords
        coords      = subprocess.Popen(show_coords, stdout=subprocess.PIPE, shell=True).communicate()[0]
        coordslines = coords.split("\n")
    else:
        coordslines = open(delta, 'r')



    for line in coordslines:
        lineCount += 1
        line       = line.strip()
        #print line

        if len(line) == 0  : continue
        if lineCount < 5   : continue

        cols = line.split("\t")
        #print cols
        refStart    , refEnd    , tgtStart, tgtEnd, refLen, tgtLen = [ int(  x)  for x in cols[ 0: 6] ]
        idd                                                        =   float(cols[6])
        referenceLen, targetLen                                    = [ int(  x)  for x in cols[ 7: 9] ]
        refName     , tgtName                                      = [ x.strip() for x in cols[ 9:11] ]

        refSub = refEnd - refStart
        tgtSub = tgtEnd - tgtStart

        #print "tgt name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( tgtName, tgtStart, tgtEnd, tgtLen, targetLen   , tgtSub )
        #print "ref name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( refName, refStart, refEnd, refLen, referenceLen, refSub )
        #print "identity  %.2f"                                             % ( idd                                                     )
        #print

        refMin = min( refStart, refEnd )
        refMax = max( refStart, refEnd )
        tgtMin = min( tgtStart, tgtEnd )
        tgtMax = max( tgtStart, tgtEnd )
        d      = [refStart, refEnd, tgtStart, tgtEnd, refLen, tgtLen, refSub, tgtSub, idd, refName, tgtName]
        #print d

        if tgtName in scafLens:
            prevRefStart = scafLens[tgtName][0]
            prevRefEnd   = scafLens[tgtName][1]

            if refMin < prevRefStart:
                scafLens[tgtName][0] = refMin

            if refMax > prevRefEnd:
                scafLens[tgtName][1] = refMax


            prevTgtStart = scafLens[tgtName][3]
            prevTgtEnd   = scafLens[tgtName][4]

            if tgtMin < prevTgtStart:
                scafLens[tgtName][3] = tgtMin

            if tgtMax > prevTgtEnd:
                scafLens[tgtName][4] = tgtMax

            scafLens[tgtName][6].append(d)

        else:
            #                    0       1       2             3       4       5          6
            scafLens[tgtName] = [refMin, refMax, referenceLen, tgtMin, tgtMax, targetLen, [d]]

    scafOrder = sorted(scafLens.keys(), key=lambda s: scafLens[s][0])
    #print scafOrder


    if delta.endswith('.coords'):
        coordslines.close()


    return ( scafOrder, scafLens )



def genCoords(exporter, scafOrder, scafLens):
    """
    Check sanity of data and adds data to exporter.
    Converts query coordnates to Y coordinates where scaffolds are ordered and their lengths sum
    to create a single Y axis.
    """

    targetPos = 1
    for tgtName in scafOrder:
        #print tgtName
        refMin, refMax, referenceLen, tgtMin, tgtMax, targetLen, coordsData = scafLens[tgtName]
        #refSize = refMax - refMin

        tgtSize = tgtMax - tgtMin

        if tgtSize > targetLen:
            print "error"

        alignmentEnd = targetPos + targetLen

        for line in coordsData:
            refStart, refEnd, tgtStart, tgtEnd, refLen, tgtLen, refSub, tgtSub, idd, refName, tgtName = line
            #print line
            targetStart = targetPos + tgtStart
            targetEnd   = targetPos + tgtEnd

            plotStr    = """%d %d %.2f\n%d %d %.2f\n\n\n""" %   (
                    targetStart, refStart, idd,
                    targetEnd  , refEnd  , idd,
                )

            #print targetEnd, targetStart, alignmentEnd

            if targetEnd   > alignmentEnd:
                print " error"

            if targetStart > alignmentEnd:
                print " error"

            if abs(tgtSub) > abs(refSub * 1.1):
                #print " target size %d > ref size %d"  % (tgtSub, refSub)
                pass

            if (abs(tgtSub) > targetLen) or (abs(refSub) > (targetLen*1.1)):
                print "incongruency"
                print "tgt name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( tgtName, tgtStart, tgtEnd, tgtLen, targetLen   , tgtSub )
                print "ref name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( refName, refStart, refEnd, refLen, referenceLen, refSub )
                print "identity  %.2f"                                             % ( idd                                                     )
                print "tgtSub", abs(tgtSub), "targetLen   ", targetLen
                print "refSub", abs(refSub), "referenceLen", referenceLen
                print plotStr
                print
                sys.exit(1)


            #print "tgt name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( tgtName, tgtStart, tgtEnd, tgtLen, targetLen   , tgtSub )
            #print "ref name  %-15s start %9d end %9d len %9d size %9d sub %9d" % ( refName, refStart, refEnd, refLen, referenceLen, refSub )
            #print "identity  %.2f"                                             % ( idd                                                     )
            #print "tgtSub", abs(tgtSub), "targetLen   ", targetLen
            #print "refSub", abs(refSub), "referenceLen", referenceLen
            #print plotStr

            reg = ( refStart, refEnd, tgtStart, tgtEnd, targetStart, targetEnd, refLen, tgtLen, refSub, tgtSub, idd, refName, tgtName )

            if tgtSub > 0: # fwd
                exporter.add('fwd', reg )

            else: # rev
                exporter.add('rev', reg )

        targetPos += targetLen + 1

    print "last pos", targetPos



def parseFN(infile):
    """
    Parses file name to extract species information
    """
    bn = os.path.basename( infile )
    #solanum_lycopersicum_heinz_SL2.40ch00.fa_._solanum_arcanum_scaffold_final.assembly.fasta.delta

    print "parsing %s" % infile

    res = {}

    for label in sorted( labelFields ):
        fmt = labelFields[label][0]
        fun = labelFields[label][1]
        try:
            val = fmt.search(infile).group(1)

            val = val.replace('_', ' ')

            if fun is not None:
                val = fun( val )

            print '%s = "%s"' % ( label, val )

            res[label] = val
        except:
            print "error parsing %s in file name: %s using format %s" % (label, infile, fmt.pattern)
            sys.exit(1)

    return res



def main():
    """
    Parse all input files names, exports them to databases and creates index of all files.
    """
    outfiles = {}

    refs     = {}
    chroms   = {}
    spps     = {}
    statuses = {}

    if len(sys.argv) == 1:
        print "Usage:"
        print sys.argv[0], ' [input delta files +]'
        sys.exit(0)


    for infile in sys.argv[1:]:
        print "INFILE : %s" % infile

        hasC = False
        for compul in compulsory:
            if infile.endswith( compul ):
                hasC = True

        if not hasC:
            print "  does not have compulsory extension. skipping", compulsory
            continue

        hasF = False
        for forb in forbidden:
            if infile.endswith( forb ):
                hasF = True

        if hasF:
            print "  has compulsory extension", forbidden
            continue


        outfile  = infile + '.js'
        print "OUTFILE: %s" % outfile

        labels = parseFN( infile )


        #'.delta'               : 'Raw Dot Plot',
        #'.delta.q.delta'       : 'Clean Dot Plot',
        #'.delta.q.delta.filter': 'Clean & Filtered Dot Plot',
        #'.delta.q.delta.filter.invertions.delta': 'Clean & Filtered Dot Plot. Only Inversions',


        #'refName'    : ['(\S+?)_SL2.40ch\d+'                       , os.path.basename],
        #'chromNumber': ['SL2.40ch(\d+)'                            , None],
        #'spp'        : ['_\._(\S+)_scaffold_final\.assembly\.fasta', None],
        #'status'     : ['\.fasta(\S+)'                             , None]

        status      = labels['status'     ]
        spp         = labels['spp'        ]
        chromNumber = labels['chromNumber']
        refName     = labels['refName'    ]

        statuses[ status      ] = 1
        spps    [ spp         ] = 1
        chroms  [ chromNumber ] = 1
        refs    [ refName     ] = 1

        title  = titleFmt  % labels
        xlabel = xlabelFmt % labels
        ylabel = ylabelFmt % labels

        if not os.path.exists( outfile ):
            print "parsing delta"
            scafOrder, scafLens = parseDelta(infile)


            print "parsing coords"
            exporter = exp(outfile, refName, chromNumber, spp, status, title=title, xlabel=xlabel, ylabel=ylabel)
            genCoords(exporter, scafOrder, scafLens)
            exporter.close()

        if refName not in outfiles:
            outfiles[ refName ] = {}

        if chromNumber not in outfiles[ refName ]:
            outfiles[ refName ][ chromNumber ] = {}

        if spp not in outfiles[ refName ][ chromNumber ]:
            outfiles[ refName ][ chromNumber ][ spp ] = {}

        if status not in outfiles[ refName ][ chromNumber ][ spp ]:
            outfiles[ refName ][ chromNumber ][ spp ][ status ] = [
                [os.path.abspath(infile ), os.path.basename(infile )],
                [os.path.abspath(outfile), os.path.basename(outfile)],
            ]
        else:
            print "data read twice"
            print "ref %s chrom %s spp %s status %s" % ( refName, chromNumber, spp, status )
            sys.exit( 1 )




    with open( 'list.js', 'w' ) as fhd:
        """
        Creates a list of all available status, query species, chromosomes and references for quick listing.
        Creates a database of the available combitations and the .js files containing the data.
        outfiles[ refName ][ chromNumber ][ spp ][ status ] = <javascript database base name>
        """

        statusStr = ', '.join( [ "'%s'" % x for x in sorted(statuses) ] )
        fhd.write( 'var statuses = [%s];\n' % statusStr);

        sppStr    = ', '.join( [ "'%s'" % x for x in sorted(spps    ) ] )
        fhd.write( 'var spps     = [%s];\n' % sppStr);

        chromStr  = ', '.join( [ "'%s'" % x for x in sorted(chroms  ) ] )
        fhd.write( 'var chroms   = [%s];\n' % chromStr);

        refStr    = ', '.join( [ "'%s'" % x for x in sorted(refs    ) ] )
        fhd.write( 'var refs     = [%s];\n' % refStr);

        fhd.write( 'var filelist = {\n');


        for refName in sorted(outfiles):
            fhd.write("  '%s': {\n" % refName )

            for chromNumber in sorted(outfiles[ refName ]):
                fhd.write("    '%s': {\n" % chromNumber )

                for spp in sorted(outfiles[ refName ][ chromNumber ]):
                    fhd.write("      '%s': {\n" % spp )

                    for status in sorted(outfiles[ refName ][ chromNumber ][ spp ]):
                        filedata = outfiles[ refName ][ chromNumber ][ spp ][ status ]
                        fhd.write('        "%s": {\n' % status)
                        fhd.write('          "filename": "%s"\n' % ( filedata[1][1] ) )
                        fhd.write('        },\n')
                    fhd.write('      },\n')
                fhd.write('    },\n')
            fhd.write('  },\n')

        fhd.write('};\n')

    print "done"



if __name__ == '__main__': main()
